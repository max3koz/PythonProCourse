Які підводні камені використання асинхронних бібліотек при роботі з базами даних?
=================================================================================

1. Не всі бази підтримують асинхронність
------------------------------------------
Наприклад, sqlite3 — синхронна, блокує потік.
Потрібно використовувати aiosqlite, asyncpg, databases, або інші
async-орієнтовані бібліотеки.

2. Асинхронні драйвери ≠ Object-Relational Mapping (ORM)
----------------------------------------------------------
Багато ORM (наприклад, SQLAlchemy) мають окрему async-інтеграцію,
яка не завжди стабільна або повнофункціональна.
Вирішення проблеми використання SQLAlchemy 1.4+ з async-движком або Tortoise ORM.

3. Підключення до БД — це ресурс
----------------------------------
Якщо ти запускаєш 1000 await db.query(...) — і кожен створює нове підключення,
БД може "заткнутись" - кількість запросів у одиницю часу буде більше ніж її
пропускна здатність..
Асинхронні бібліотеки часто не мають пулу з'єднань за замовчуванням.
Порібно використовувати пул з'єднань (max_connections, pool_size)
або обмежуй кількість одночасних запитів через asyncio.Semaphore.

4. Асинхронний код ≠ автоматично швидкий
------------------------------------------
Якщо БД повільна або запити не оптимізовані — await не допоможе.
Асинхронність лише дозволяє не блокувати інші задачі.
Використовувати індекси, кешування.

5. Транзакції можуть бути tricky
----------------------------------
Асинхронні транзакції потребують ʼasyncʼ with або спеціальних менеджерів.
Якщо не закрити транзакцію — вона зависне або заблокує таблицю.
Потрібно завжди використовувати:
  async with db.transaction():
  await db.begin() / await db.commit().